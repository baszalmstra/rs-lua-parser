// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-syntax` is run
// Do not edit manually

#![allow(bad_style, missing_docs, unreachable_pub)]
#![cfg_attr(rustfmt, rustfmt_skip)]
use super::SyntaxInfo;

/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
pub enum SyntaxKind {
    // Technical SyntaxKinds: they appear temporally during parsing,
    // but never end up in the final tree
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    PLUS,
    MINUS,
    STAR,
    SLASH,
    PERCENT,
    CARET,
    HASH,
    DOT,
    LT,
    GT,
    EQ,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACKET,
    R_BRACKET,
    SEMI,
    COLON,
    COMMA,
    EQEQ,
    NEQ,
    LTEQ,
    GTEQ,
    DOTDOT,
    DOTDOTDOT,
    COLONCOLON,
    AND_KW,
    BREAK_KW,
    DO_KW,
    ELSE_KW,
    ELSEIF_KW,
    END_KW,
    FALSE_KW,
    FOR_KW,
    FUNCTION_KW,
    GOTO_KW,
    IF_KW,
    IN_KW,
    LOCAL_KW,
    NIL_KW,
    NOT_KW,
    OR_KW,
    REPEAT_KW,
    RETURN_KW,
    THEN_KW,
    TRUE_KW,
    UNTIL_KW,
    WHILE_KW,
    INT_NUMBER,
    FLOAT_NUMBER,
    STRING,
    ERROR,
    IDENT,
    WHITESPACE,
    COMMENT,
    CHUNK,
    // Technical kind so that we can cast from u16 safely
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;

impl From<u16> for SyntaxKind {
    fn from(d: u16) -> SyntaxKind {
        assert!(d <= (__LAST as u16));
        unsafe { std::mem::transmute::<u16, SyntaxKind>(d) }
    }
}

impl From<SyntaxKind> for u16 {
    fn from(k: SyntaxKind) -> u16 {
        k as u16
    }
}

impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        match self {
            | AND_KW
            | BREAK_KW
            | DO_KW
            | ELSE_KW
            | ELSEIF_KW
            | END_KW
            | FALSE_KW
            | FOR_KW
            | FUNCTION_KW
            | GOTO_KW
            | IF_KW
            | IN_KW
            | LOCAL_KW
            | NIL_KW
            | NOT_KW
            | OR_KW
            | REPEAT_KW
            | RETURN_KW
            | THEN_KW
            | TRUE_KW
            | UNTIL_KW
            | WHILE_KW
                => true,
            _ => false
        }
    }

    pub fn is_symbol(self) -> bool {
            match self {
                | PLUS
                | MINUS
                | STAR
                | SLASH
                | PERCENT
                | CARET
                | HASH
                | DOT
                | LT
                | GT
                | EQ
                | L_PAREN
                | R_PAREN
                | L_CURLY
                | R_CURLY
                | L_BRACKET
                | R_BRACKET
                | SEMI
                | COLON
                | COMMA
                | EQEQ
                | NEQ
                | LTEQ
                | GTEQ
                | DOTDOT
                | DOTDOTDOT
                | COLONCOLON
                    => true,
                _ => false
            }
    }

    pub fn is_literal(self) -> bool {
            match self {
                | INT_NUMBER
                | FLOAT_NUMBER
                | STRING
                    => true,
                _ => false
            }
    }

    pub(crate) fn info(self) -> &'static SyntaxInfo {
            match self {
                PLUS => &SyntaxInfo { name: "PLUS" },
                MINUS => &SyntaxInfo { name: "MINUS" },
                STAR => &SyntaxInfo { name: "STAR" },
                SLASH => &SyntaxInfo { name: "SLASH" },
                PERCENT => &SyntaxInfo { name: "PERCENT" },
                CARET => &SyntaxInfo { name: "CARET" },
                HASH => &SyntaxInfo { name: "HASH" },
                DOT => &SyntaxInfo { name: "DOT" },
                LT => &SyntaxInfo { name: "LT" },
                GT => &SyntaxInfo { name: "GT" },
                EQ => &SyntaxInfo { name: "EQ" },
                L_PAREN => &SyntaxInfo { name: "L_PAREN" },
                R_PAREN => &SyntaxInfo { name: "R_PAREN" },
                L_CURLY => &SyntaxInfo { name: "L_CURLY" },
                R_CURLY => &SyntaxInfo { name: "R_CURLY" },
                L_BRACKET => &SyntaxInfo { name: "L_BRACKET" },
                R_BRACKET => &SyntaxInfo { name: "R_BRACKET" },
                SEMI => &SyntaxInfo { name: "SEMI" },
                COLON => &SyntaxInfo { name: "COLON" },
                COMMA => &SyntaxInfo { name: "COMMA" },
                EQEQ => &SyntaxInfo { name: "EQEQ" },
                NEQ => &SyntaxInfo { name: "NEQ" },
                LTEQ => &SyntaxInfo { name: "LTEQ" },
                GTEQ => &SyntaxInfo { name: "GTEQ" },
                DOTDOT => &SyntaxInfo { name: "DOTDOT" },
                DOTDOTDOT => &SyntaxInfo { name: "DOTDOTDOT" },
                COLONCOLON => &SyntaxInfo { name: "COLONCOLON" },
                AND_KW => &SyntaxInfo { name: "AND_KW" },
                BREAK_KW => &SyntaxInfo { name: "BREAK_KW" },
                DO_KW => &SyntaxInfo { name: "DO_KW" },
                ELSE_KW => &SyntaxInfo { name: "ELSE_KW" },
                ELSEIF_KW => &SyntaxInfo { name: "ELSEIF_KW" },
                END_KW => &SyntaxInfo { name: "END_KW" },
                FALSE_KW => &SyntaxInfo { name: "FALSE_KW" },
                FOR_KW => &SyntaxInfo { name: "FOR_KW" },
                FUNCTION_KW => &SyntaxInfo { name: "FUNCTION_KW" },
                GOTO_KW => &SyntaxInfo { name: "GOTO_KW" },
                IF_KW => &SyntaxInfo { name: "IF_KW" },
                IN_KW => &SyntaxInfo { name: "IN_KW" },
                LOCAL_KW => &SyntaxInfo { name: "LOCAL_KW" },
                NIL_KW => &SyntaxInfo { name: "NIL_KW" },
                NOT_KW => &SyntaxInfo { name: "NOT_KW" },
                OR_KW => &SyntaxInfo { name: "OR_KW" },
                REPEAT_KW => &SyntaxInfo { name: "REPEAT_KW" },
                RETURN_KW => &SyntaxInfo { name: "RETURN_KW" },
                THEN_KW => &SyntaxInfo { name: "THEN_KW" },
                TRUE_KW => &SyntaxInfo { name: "TRUE_KW" },
                UNTIL_KW => &SyntaxInfo { name: "UNTIL_KW" },
                WHILE_KW => &SyntaxInfo { name: "WHILE_KW" },
                INT_NUMBER => &SyntaxInfo { name: "INT_NUMBER" },
                FLOAT_NUMBER => &SyntaxInfo { name: "FLOAT_NUMBER" },
                STRING => &SyntaxInfo { name: "STRING" },
                ERROR => &SyntaxInfo { name: "ERROR" },
                IDENT => &SyntaxInfo { name: "IDENT" },
                WHITESPACE => &SyntaxInfo { name: "WHITESPACE" },
                COMMENT => &SyntaxInfo { name: "COMMENT" },
                CHUNK => &SyntaxInfo { name: "CHUNK" },
                TOMBSTONE => &SyntaxInfo { name: "TOMBSTONE" },
                EOF => &SyntaxInfo { name: "EOF" },
                __LAST => &SyntaxInfo { name: "__LAST" },
            }
        }

    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
            let kw = match ident {
                "and" => AND_KW,
                "break" => BREAK_KW,
                "do" => DO_KW,
                "else" => ELSE_KW,
                "elseif" => ELSEIF_KW,
                "end" => END_KW,
                "false" => FALSE_KW,
                "for" => FOR_KW,
                "function" => FUNCTION_KW,
                "goto" => GOTO_KW,
                "if" => IF_KW,
                "in" => IN_KW,
                "local" => LOCAL_KW,
                "nil" => NIL_KW,
                "not" => NOT_KW,
                "or" => OR_KW,
                "repeat" => REPEAT_KW,
                "return" => RETURN_KW,
                "then" => THEN_KW,
                "true" => TRUE_KW,
                "until" => UNTIL_KW,
                "while" => WHILE_KW,
                _ => return None,
            };
            Some(kw)
    }

    pub fn from_char(c: char) -> Option<SyntaxKind> {
            let tok = match c {
                '+' => PLUS,
                '-' => MINUS,
                '*' => STAR,
                '/' => SLASH,
                '%' => PERCENT,
                '^' => CARET,
                '#' => HASH,
                '.' => DOT,
                '<' => LT,
                '>' => GT,
                '=' => EQ,
                '(' => L_PAREN,
                ')' => R_PAREN,
                '{' => L_CURLY,
                '}' => R_CURLY,
                '[' => L_BRACKET,
                ']' => R_BRACKET,
                ';' => SEMI,
                ':' => COLON,
                ',' => COMMA,
                _ => return None,
            };
            Some(tok)
        }
}



